{"ast":null,"code":"const pMap = require('p-map');\n\nconst cache = require('memory-cache');\n\nconst {\n  endpoints\n} = require('./endpoints.js');\n\nconst {\n  rootEndpoints\n} = require('./rootEndpoints.js');\n\nconst {\n  getJSON\n} = require('./getter.js');\n\nconst {\n  Values\n} = require('./values.js');\n\nconst {\n  handleError\n} = require('./error.js');\n\nclass Pokedex {\n  constructor(config) {\n    this.values = new Values(config, new cache.Cache()); // add to Pokedex.prototype all our endpoint functions\n\n    endpoints.forEach(endpoint => {\n      this[endpoint[0]] = async (input, cb) => {\n        try {\n          const mapper = async name => {\n            const queryRes = await getJSON(this.values, `${this.values.protocol}${this.values.hostName}${this.values.versionPath}${endpoint[1]}/${name}/`);\n            return queryRes;\n          };\n\n          if (input) {\n            // if the user has submitted a Name or an Id, return the Json promise\n            if (typeof input === 'number' || typeof input === 'string') {\n              return getJSON(this.values, `${this.values.protocol}${this.values.hostName}${this.values.versionPath}${endpoint[1]}/${input}/`, cb);\n            } // if the user has submitted an Array\n            // return a new promise which will resolve when all getJSON calls are ended\n            else if (typeof input === 'object') {\n                // fetch data asynchronously to be faster\n                const mappedResults = await pMap(input, mapper, {\n                  concurrency: 4\n                });\n\n                if (cb) {\n                  cb(mappedResults);\n                }\n\n                return mappedResults;\n              }\n          }\n        } catch (error) {\n          handleError(error, cb);\n        }\n      };\n    });\n    rootEndpoints.forEach(rootEndpoint => {\n      this[rootEndpoint[0]] = async (config, cb) => {\n        try {\n          let limit = this.values.limit;\n          let offset = this.values.offset;\n\n          if (config) {\n            if (config.hasOwnProperty('limit')) {\n              limit = config.limit;\n            }\n\n            if (config.hasOwnProperty('offset')) {\n              offset = config.offset;\n            }\n          }\n\n          return getJSON(this.values, `${this.values.protocol}${this.values.hostName}${this.values.versionPath}${rootEndpoint[1]}?limit=${limit}&offset=${offset}`, cb);\n        } catch (error) {\n          handleError(error, cb);\n        }\n      };\n    });\n  }\n\n  async resource(path, cb) {\n    let result;\n\n    try {\n      if (typeof path === 'string') {\n        result = getJSON(this.values, path);\n      } else if (typeof path === 'object') {\n        result = Promise.all(path.map(p => getJSON(this.values, p)));\n      } else {\n        throw 'String or Array required';\n      }\n\n      if (cb) {\n        cb(result); // TODO: check if this callback is called with a pending Promise or an actual result\n      }\n\n      return result;\n    } catch (error) {\n      throw new Error(error);\n    }\n  }\n\n  getConfig() {\n    return this.values;\n  }\n\n  cacheSize() {\n    // Retuns the current number of entries in the cache\n    return this.values.cache.size();\n  }\n\n  clearCache() {\n    // Deletes all keys in cache\n    this.values.cache.clear();\n  }\n\n}\n\nmodule.exports = Pokedex;","map":{"version":3,"sources":["/mnt/c/Users/viggn/OneDrive/Desktop/pokedex/node_modules/pokedex-promise-v2/src/index.js"],"names":["pMap","require","cache","endpoints","rootEndpoints","getJSON","Values","handleError","Pokedex","constructor","config","values","Cache","forEach","endpoint","input","cb","mapper","name","queryRes","protocol","hostName","versionPath","mappedResults","concurrency","error","rootEndpoint","limit","offset","hasOwnProperty","resource","path","result","Promise","all","map","p","Error","getConfig","cacheSize","size","clearCache","clear","module","exports"],"mappings":"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","sourcesContent":["const pMap = require('p-map')\nconst cache = require('memory-cache')\n\nconst { endpoints } = require('./endpoints.js')\nconst { rootEndpoints } = require('./rootEndpoints.js')\nconst { getJSON } = require('./getter.js')\nconst { Values } = require('./values.js')\nconst { handleError } = require('./error.js')\n\n\nclass Pokedex {\n    constructor(config) {\n        this.values = new Values(config, new cache.Cache())\n        \n        // add to Pokedex.prototype all our endpoint functions\n        endpoints.forEach(endpoint => {\n            this[endpoint[0]] = async (input, cb) => {\n                try {\n                    const mapper = async name => {\n                        const queryRes = await getJSON(this.values, `${this.values.protocol}${this.values.hostName}${this.values.versionPath}${endpoint[1]}/${name}/`)\n                        return queryRes\n                    }\n    \n                    if (input) {\n    \n                        // if the user has submitted a Name or an Id, return the Json promise\n                        if (typeof input === 'number' || typeof input === 'string') {\n                            return getJSON(this.values, `${this.values.protocol}${this.values.hostName}${this.values.versionPath}${endpoint[1]}/${input}/`, cb) \n                        }\n    \n                        // if the user has submitted an Array\n                        // return a new promise which will resolve when all getJSON calls are ended\n                        else if (typeof input === 'object') {\n                            // fetch data asynchronously to be faster\n                            const mappedResults = await pMap(input, mapper, {concurrency: 4})\n                            if (cb) {\n                                cb(mappedResults)\n                            }\n                            return mappedResults\n                        }\n                    }\n                } catch (error) {\n                    handleError(error, cb)\n                }\n            }\n        })\n\n        rootEndpoints.forEach(rootEndpoint => {\n            this[rootEndpoint[0]] = async (config, cb) => {\n                try {\n                    let limit = this.values.limit\n                    let offset = this.values.offset\n                    if (config) {\n                        if (config.hasOwnProperty('limit')) {\n                            limit = config.limit\n                        }\n                        if (config.hasOwnProperty('offset')) {\n                            offset = config.offset\n                        }\n                    }\n                    return getJSON(this.values, `${this.values.protocol}${this.values.hostName}${this.values.versionPath}${rootEndpoint[1]}?limit=${limit}&offset=${offset}`, cb)\n                } catch (error) {\n                    handleError(error, cb)\n                }\n            }\n        })\n    }\n\n    async resource(path, cb) {\n        let result\n        try {\n            if (typeof path === 'string') {\n                result = getJSON(this.values, path)\n            } else if (typeof path === 'object') {\n                result = Promise.all(path.map(p => getJSON(this.values, p)))\n            } else {\n                throw 'String or Array required'\n            }\n            if (cb) {\n                cb(result) // TODO: check if this callback is called with a pending Promise or an actual result\n            }\n            return result\n        } catch (error) {\n            throw new Error(error)\n        }\n    }\n\n    getConfig() {\n        return this.values\n    }\n\n    cacheSize() {\n        // Retuns the current number of entries in the cache\n        return this.values.cache.size()\n    }\n\n    clearCache() {\n        // Deletes all keys in cache\n        this.values.cache.clear()\n    }\n}\n\nmodule.exports = Pokedex\n"]},"metadata":{},"sourceType":"script"}